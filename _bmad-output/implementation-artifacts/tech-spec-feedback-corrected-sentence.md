---
title: 'Enhanced Feedback with Corrected Sentence Display'
slug: 'feedback-corrected-sentence'
created: '2026-02-23'
status: 'ready-for-dev'
stepsCompleted: [1, 2, 3, 4]
tech_stack: [rust, crossterm]
files_to_modify: [agent/language_trainer.agent.md, client/src/main.rs]
code_patterns: [feedback-parsing, ansi-color-display]
test_patterns: [unit-tests-inline]
---

# Tech-Spec: Enhanced Feedback with Corrected Sentence Display

**Created:** 2026-02-23

## Overview

### Problem Statement

After receiving feedback, the user sees individual error corrections (red for grammar, blue for naturalness) but has no view of the final corrected sentence. They must mentally reconstruct what they should have said, which adds cognitive load and reduces the learning value of the feedback.

### Solution

Add a `CORRECTED:` line to the `[FEEDBACK]` block in Claude's output. This line contains the user's full sentence with corrections applied, where corrected parts are marked with `<<...>>` delimiters. The client parses this line and displays it with corrections highlighted in green, giving the user an instant visual of their improved sentence.

### Scope

**In Scope:**
- Update agent prompt to instruct Claude to produce a `CORRECTED:` line
- Parse `CORRECTED:` line in client `display_feedback()`
- Display corrected sentence with green-highlighted parts
- Handle edge cases (no CORRECTED line, malformed markers)

**Out of Scope:**
- Protocol changes
- Server/orchestrator code changes
- Changes to feedback parsing in orchestrator (`parse_feedback()`)
- Changes to TTS pipeline

## Context for Development

### Codebase Patterns

- Feedback is generated by Claude in `[FEEDBACK]...[/FEEDBACK]` blocks
- Orchestrator `parse_feedback()` in `voice_loop.rs` extracts the raw feedback text and sends it via `OrchestratorMsg::FeedbackText`
- Server routes `FeedbackText` → `ServerMsg::Feedback` to client
- Client `display_feedback()` in `main.rs:518` iterates lines, classifies them via `classify_feedback_line()`, and renders with ANSI colors
- `classify_feedback_line()` in `main.rs:486`: returns `("red", text)` for `RED:`/`ORANGE:` prefixes, `("blue", text)` for `BLUE:`/`YELLOW:`/`GREEN:` prefixes, `("blue", text)` for any unknown `ALLCAPS:` prefix, or `None` for unprefixed lines (defaults to blue)
- **CRITICAL**: The ALLCAPS catch-all in `classify_feedback_line()` would match `CORRECTED:` and classify it as blue. The CORRECTED line must be extracted BEFORE lines are passed to `classify_feedback_line()`.
- `display_feedback()` in `main.rs:518`: iterates lines, skips empty, classifies, renders `✗` in red or `➜` in blue via ANSI escape codes
- Agent prompt section "Language Feedback Display" in `language_trainer.agent.md:178-208` defines the FEEDBACK format, examples, and rules
- `ORANGE:` and `YELLOW:` are kept as safety nets in `classify_feedback_line` (mapping to red and blue respectively) in case Claude uses them despite prompt instructions. `GREEN:` should be removed as it conflicts semantically with the new green CORRECTED display.
- `main.rs` does NOT have a `#[cfg(test)]` module — one must be created for new tests

### Files to Reference

| File | Purpose |
| ---- | ------- |
| `agent/language_trainer.agent.md:178-208` | Agent prompt — feedback format instructions and examples |
| `client/src/main.rs:486-511` | `classify_feedback_line()` — prefix parsing and severity classification |
| `client/src/main.rs:518-532` | `display_feedback()` — ANSI color rendering loop |
| `orchestrator/src/voice_loop.rs:62-83` | `parse_feedback()` — extracts feedback block (NOT modified) |

### Technical Decisions

- **Delimiter choice**: `<<...>>` for marking corrected parts — unlikely to appear in natural text, easy to parse with simple string scanning, no conflict with existing markers. Known limitation: French guillemets use `<<` `>>` but this is extremely rare in spoken English practice sessions.
- **CORRECTED line in prompt vs client**: The prompt tells Claude the CORRECTED line is mandatory when a [FEEDBACK] block is present. The client implements graceful degradation if Claude omits it — no crash, just no green line displayed. This is "mandatory in prompt, tolerant in code."
- **Parsing is client-only**: The orchestrator passes feedback text as-is; only the client display logic changes.
- **Separate handling for CORRECTED**: The CORRECTED line is extracted from the feedback text BEFORE the main line loop (to avoid being caught by the ALLCAPS catch-all in `classify_feedback_line()`). It is displayed after all RED/BLUE lines.
- **Case-insensitive prefix matching**: The CORRECTED line detection uses case-insensitive matching (`CORRECTED:`, `Corrected:`, `corrected:` all accepted) because Claude is not case-deterministic. The extraction trims content after the prefix.
- **Multiple CORRECTED lines**: If Claude produces multiple CORRECTED lines, take the LAST one (most likely to be the final corrected version). Earlier ones are skipped silently.
- **Graceful degradation**: If CORRECTED line has no `<<...>>` markers, display the entire line in green. If markers are malformed (unmatched `<<` without `>>`), treat text from `<<` onwards as corrected (the `<<` delimiter is consumed, not displayed). Stray `>>` without preceding `<<` are treated as literal text. Always emit ANSI reset `\x1b[0m` at end of line.
- **Safety net prefixes**: Keep `ORANGE:` → red and `YELLOW:` → blue as safety nets in `classify_feedback_line`. Only remove `GREEN:` (conflicts with new green CORRECTED display).
- **Multi-sentence turns**: The CORRECTED line should reproduce ALL sentences the user spoke, with corrections applied. Uncorrected sentences are included verbatim (no `<<...>>` around them). This gives the user a complete view of what they said, improved.

## Implementation Plan

### Tasks

- [ ] Task 1: Update agent prompt with CORRECTED line format
  - File: `agent/language_trainer.agent.md`
  - Action: In the "Language Feedback Display" section (line 178+):
    1. Add `CORRECTED:` line format after the RED:/BLUE: line descriptions. The instruction: "As the last line of the [FEEDBACK] block, ALWAYS add a CORRECTED: line containing the user's full original message with all corrections applied. Wrap each corrected part in `<<...>>` delimiters so the client can highlight them in green. Include uncorrected sentences verbatim (without `<<...>>`)."
    2. Add rule: "The CORRECTED: line is mandatory when a [FEEDBACK] block is present. It must be the last line before [/FEEDBACK]."
    3. Update the "Maximum 3 lines" rule to: "Maximum 3 RED/BLUE lines per block, plus the mandatory CORRECTED line."
    4. Add two examples — a multi-correction example and a minimal single-correction example:
       ```
       Example with two corrections:
       [FEEDBACK]
       RED: "I have went to the store" → "I went to the store" (past simple, not present perfect)
       BLUE: "it is good because it has many things" → "it's appealing for its variety" (more natural)
       CORRECTED: I <<went>> to the store. <<It's appealing for its variety>>.
       [/FEEDBACK]

       Example with a single correction:
       [FEEDBACK]
       RED: "She don't like it" → "She doesn't like it" (third person singular)
       CORRECTED: She <<doesn't>> like it.
       [/FEEDBACK]
       ```
    5. Add rule: "The CORRECTED line reproduces what the user said with corrections applied. Do NOT invent words or join separate sentences with conjunctions — keep the sentence boundaries as the user spoke them. Use `<<...>>` ONLY around the corrected parts. Do NOT use any other delimiter."
  - Notes: Keep existing rules intact. The CORRECTED line is an addition, not a replacement.

- [ ] Task 2: Add `parse_corrected_parts()` and `display_corrected_line()` in client
  - File: `client/src/main.rs`
  - Action:
    1. Add `parse_corrected_parts(text: &str) -> Vec<(bool, &str)>` that splits on `<<` and `>>` delimiters. Contract:
       - Splits text on `<<` first, then each fragment on `>>`.
       - Text before the first `<<` → `(false, text)`.
       - Text between `<<` and `>>` → `(true, text)`.
       - Text after `>>` and before next `<<` → `(false, text)`.
       - Empty segments are filtered out.
       - If no `<<` markers found at all → returns `[(true, text)]` (graceful degradation — whole line green).
       - If empty input → returns empty vec.
       - Unmatched `<<` (no closing `>>`) → remaining text after `<<` is `(true, text)`, delimiter consumed (not in output).
       - Stray `>>` without preceding `<<` → treated as literal text (part of `(false, ...)` segment).
    2. Add `display_corrected_line(text: &str)` that:
       - Trims input before parsing.
       - Calls `parse_corrected_parts()`.
       - If result is empty, returns without printing.
       - Renders: prefix `  \x1b[32m✓\x1b[0m `, then for each segment: `\x1b[32m{text}\x1b[0m` if corrected, `{text}` if not.
       - Ends with `\x1b[0m` reset and `eprintln!()`.
  - Notes: `parse_corrected_parts()` is called by `display_corrected_line()` in non-test code, so no dead-code warning. Use `eprint!` for inline segments.

- [ ] Task 3: Update `display_feedback()` to handle CORRECTED lines
  - File: `client/src/main.rs`
  - Action: In `display_feedback()`:
    1. **BEFORE the line iteration loop**: scan all lines. For each trimmed line, check if it starts with `CORRECTED:` using **case-insensitive** matching (check if the first 10 chars uppercased equal `"CORRECTED:"`). Extract the LAST matching line's content (after the prefix, trimmed). Store as `Option<&str>`.
    2. In the main loop, skip any line whose trimmed form matches `CORRECTED:` case-insensitively (already extracted — prevents it from hitting `classify_feedback_line()`'s ALLCAPS catch-all or falling through as unprefixed blue).
    3. After the loop (before the closing `---` separator), if a CORRECTED line was found, call `display_corrected_line()` with the extracted content.
  - Notes: The CORRECTED line is displayed last, after all RED/BLUE lines, providing a visual summary.

- [ ] Task 4: Clean up `classify_feedback_line()` — remove GREEN: prefix only
  - File: `client/src/main.rs`
  - Action: Remove `"GREEN:"` from the soft-suggestion prefix list in `classify_feedback_line()` (line 494). Keep `"YELLOW:"` (→ blue) and keep `"ORANGE:"` (→ red) as safety nets in case Claude uses them.
  - Notes: GREEN conflicts semantically with the new green CORRECTED display. ORANGE/YELLOW remain as safety nets.

- [ ] Task 5: Add unit tests for corrected line parsing
  - File: `client/src/main.rs`
  - Action: Create a `#[cfg(test)] mod tests` block at the end of `main.rs` (does not exist yet). Add tests:
    1. `parse_corrected_parts_with_markers` — `"I <<went>> to the store"` → `[(false, "I "), (true, "went"), (false, " to the store")]`
    2. `parse_corrected_parts_without_markers` — `"I went to the store"` → `[(true, "I went to the store")]` (graceful degradation)
    3. `parse_corrected_parts_multiple_markers` — `"I <<went>> to <<the>> store"` → `[(false, "I "), (true, "went"), (false, " to "), (true, "the"), (false, " store")]`
    4. `parse_corrected_parts_empty` — `""` → empty vec
    5. `parse_corrected_parts_unmatched_open` — `"I <<went to the store"` → `[(false, "I "), (true, "went to the store")]` (delimiter consumed, not in output)
    6. `parse_corrected_parts_adjacent_markers` — `"<<foo>><<bar>>"` → `[(true, "foo"), (true, "bar")]` (no empty segments)
    7. `parse_corrected_parts_stray_close` — `"I went>> to the store"` → `[(true, "I went>> to the store")]` or treats `>>` as literal text
  - Notes: Test `parse_corrected_parts()` directly. Explicit expected outputs for every test case.

- [ ] Task 6: Validation
  - Action: Run `make check` — fmt + clippy (with `-D warnings`) + all tests pass, zero warnings
  - Notes: `parse_corrected_parts()` is used by `display_corrected_line()` in non-test code — no dead-code warning.

### Acceptance Criteria

- [ ] AC 1: Given a feedback block with RED/BLUE lines and a CORRECTED line, when `display_feedback()` is called, then the RED lines display in red with ✗, the BLUE lines display in blue with ➜, and the CORRECTED line displays last with ✓ where `<<...>>` parts are green and the rest is default color.

- [ ] AC 2: Given a feedback block WITHOUT a CORRECTED line (Claude omits it), when `display_feedback()` is called, then the behavior is identical to the current implementation — no regression.

- [ ] AC 3: Given a CORRECTED line without any `<<...>>` markers, when `display_corrected_line()` is called, then the entire line is displayed in green (graceful degradation).

- [ ] AC 4: Given a CORRECTED line with malformed markers (e.g., `<<` without closing `>>`), when `display_corrected_line()` is called, then the remaining text from the unmatched `<<` onwards is displayed in green (delimiter consumed) — no crash, no panic.

- [ ] AC 5: Given the updated agent prompt, when Claude detects errors in the user's speech, then the [FEEDBACK] block includes a CORRECTED: line as its last line with corrected parts wrapped in `<<...>>`.

- [ ] AC 6: Given all changes, when `make check` is run, then all existing + new tests pass with zero warnings.

- [ ] AC 7: Given a feedback block with multiple CORRECTED lines, when `display_feedback()` is called, then only the LAST CORRECTED line is displayed (others are silently skipped).

- [ ] AC 8: Given a CORRECTED line with mixed case prefix (e.g., `Corrected:` or `corrected:`), when `display_feedback()` is called, then the line is correctly detected and displayed in green.

## Additional Context

### Dependencies

None — pure enhancement of existing feature, no new crates or protocol messages.

### Testing Strategy

- **Unit tests**: `parse_corrected_parts()` tested with 7 cases: markers present, no markers, multiple markers, empty input, unmatched open, adjacent markers, stray close. All with explicit expected outputs.
- **No integration tests needed**: No protocol/server changes
- **Manual E2E**: Conversation with deliberate errors → verify red/blue lines appear as before + green corrected sentence appears at the bottom
- **Prompt validation**: During manual E2E, verify across 5+ feedback occurrences that Claude consistently produces the CORRECTED line. If compliance is below ~80%, revisit prompt wording.

### Notes

- The prompt tells Claude CORRECTED is mandatory; the client tolerates its absence. This "mandatory in prompt, tolerant in code" approach maximizes compliance while preventing crashes.
- The `<<...>>` delimiter was chosen over alternatives (`{...}`, `**...**`, `[...]`) because: double angle brackets are extremely rare in natural English speech, they don't conflict with any existing markers in the system, and they're trivial to parse with simple string splitting. Known limitation: French guillemets use similar characters, but this is irrelevant in spoken English practice.
- If Claude produces multiple CORRECTED lines, the last one wins. This handles the case where Claude self-corrects within the feedback block.
- The CORRECTED line is extracted before `classify_feedback_line()` to avoid being caught by the ALLCAPS catch-all pattern.
- Case-insensitive matching for the CORRECTED prefix handles Claude's non-deterministic casing.
- For multi-sentence turns, the CORRECTED line includes ALL sentences (corrected ones with `<<...>>`, uncorrected ones verbatim). This gives the user a complete view.
- `ORANGE:` and `YELLOW:` are kept as safety nets in `classify_feedback_line`. Only `GREEN:` is removed (semantic conflict with new feature).

### Adversarial Review Applied

**Round 1 findings addressed:**
- **R1-F1** (Critical): CORRECTED extraction happens BEFORE classify_feedback_line
- **R1-F2** (Medium): "max 3 RED/BLUE lines + mandatory CORRECTED line"
- **R1-F3** (High): "mandatory in prompt, tolerant in code" throughout
- **R1-F7** (Medium): Take LAST CORRECTED line, added AC 7
- **R1-F8** (High): Rewrote example with single-sentence case, added rule against inventing words
- **R1-F5** (Medium): `#[cfg(test)]` module must be created in main.rs

**Round 2 findings addressed:**
- **R2-F1** (High): Fixed example — separate sentences with periods, not comma-joined
- **R2-F2** (Medium): Added stray `>>` handling (literal text) + test case 7
- **R2-F3** (High): Case-insensitive prefix matching, added AC 8
- **R2-F4** (Low): Empty input → empty vec (explicit)
- **R2-F8** (Medium): Added minimal single-correction example in prompt
- **R2-F10** (Medium): Multi-sentence rule — include ALL sentences, uncorrected ones verbatim
- **R2-F12** (Low): Clarified: `<<` delimiter consumed, not in output
- **R2-F13** (Medium): Keep ORANGE/YELLOW safety nets, only remove GREEN
